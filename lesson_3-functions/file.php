<?php

declare(strict_types=1); // директива, режим строй типизации (1 строгая типизация)
// функция, которая принимает на вход 2 числа и возвращает результат сложения этих чисел
$num1 = 2;
$num2 = 10;
function sum(int $a, int $b)
{
	return $a + $b;
}
// после именованных функций ; не ставим 
// имена аргументов тоже начинаем с $
var_dump(sum(2, 1));
// echo всегда приводит к строке 
// echo [3, 6, 78]; выведите только Array

// объявление функции
function get_sum($a,  $b)
{
	// $a1 = 1 переменная а1 так же доступна функции 
	return $a + $b;
}
//вызов функции 
get_sum($num1, $num2);
var_dump(get_sum($num1, $num2)); // 12
var_dump(get_sum('56', '1')); // 57

$x = 6;
$y = -2;
var_dump(get_sum($x, $y)); // 4

// принудительно задать тип данных на вход в функцию array или string
function some_func(array|string $arr)
{
}
// устанавливаем значение переменно $name по умолчанию 'Гость'
function greeting($name = 'Гость')
{
	return "<h1>Добро пожаловать $name</h1>";
}
echo greeting();
echo greeting('Глеб');

// функция принимает 2 аргумента $email обязательный $name не обязательный и идут после обязательных 
function greeting2($email, $name = 'Гость')
{
	return "<h1> Добро пожаловать, $name</h1>
	<p> Ваш email: $email</p>";
}

echo greeting2('qwe@mail.ru');
echo greeting2('qwe@mail.ru', 'Глеб');

function minus($a, $b = 0)
{
	return $a - $b;
}
// var_dump(minus()); ошибка тк необходим обязательный аргумент
minus(4); // 
var_dump(minus(4, 1)); //3
var_dump(minus(4, 2, 6));  // 2

// передача аргумента по ссылке 
function add_word(string &$name)
{
	$name .= ' Большой';
}

$name = 'Глеб';
add_word($name);

$some_var = 'Торт';
add_word($some_var);

$lang = 'php';

var_dump($name);
var_dump($some_var);
var_dump($lang);

// указываем типы данных которые вернет функция :int|float|bool 
function division($a, $b): int|float|bool
{
	if ($b === 0) return false; // return -прерывает функцию
	return $a / $b;
}
$num1 = 9;
$num2 = 0;
var_dump(division($num1, $num2)); // false
var_dump(division(6, 2)); // 3 

//! если в функции не будет прописан return то результат будет null 
// из функции можно вернуть любой тип данных 

//! можно указать тип данных который будет возвращать функция, и что бы указать тип данных после круглых скобок ставим :  (function division($a, $b):int) если int то может возвращать только int и ничего больше если функция возвращает данных не тот тип данных и при строгом режиме будет ошибка, без строго режима будет приведение к типу int 
// если после скобок поставить :?int - то функция будет возвращать либо int либо null
// если после скобок :int|bool|float то мы перечисляем какие типы могут быть, работает только 8 версии php 


// "Деструктурирование массива" (Array destructuring)

function get_data()
{
	return ['Глеб', 20];
}
$data = get_data();
$name = $data[0]; // Глеб 
$age = $data[1]; //20

// деструктурирования массивов, используя синтаксис list()
$data = get_data();
list($name, $age) = get_data();
echo "Имя: $name, Возраст: $age";
// После выполнения list($name, $age) = get_data(); переменным $name и $age будут присвоены значения из массива get_data(), т.е. $name будет равно 'Глеб', а $age будет равно 20.

// замена 3 последних строчек
list($name, $age) = get_data(); // ['Глеб', 20]; это как деструктуризация массива в js , list это специальная функция 

function sum1(...$nums) // после добавления ... к аргумент означает что мы можем передать в функцию sum1 любое количество аргументов и все они соберутся в качестве массива 
{
	$acc = 0;
	foreach ($nums as $num) {
		$acc += $num;
	}
	return $acc;
}
var_dump(sum1(1, 2, 3, 4)); // 10
var_dump(sum1(1, 2, 3, 4));
var_dump(sum1(1));
var_dump(sum1(1, 78, 61));

// вызов функции через переменную //! использовать только когда нужно, например если у нас есть несколько функций, выполняющих одно и то же действие для разных типов данных, то мы можем выбирать нужную функцию, исходя из типа данных.

function create_greeting(string $name = 'Гость')
{
	return "<h2>Добро пожаловать, $name</h2>";
}
echo create_greeting();
$func_name = 'create_greeting'; // переменная хранит название функции в виде строки 
echo $func_name(); // при вызове этой переменной $func_name() будет вызвана функция create_greeting

// ============

//1. Создается анонимная функция, которая принимает на вход один аргумент типа int и возвращает результат его возведения в квадрат (выражение $a * $a).

$sqrt = function (int $a) {
	return $a * $a;
};
//2. Вызывается анонимная функция, передавая ей аргумент 34. Результат возведения в квадрат 34 равен 1156. Результат выводится с помощью var_dump.
var_dump($sqrt(34));

//3. Определяется функция change_arr, которая принимает на вход массив и функцию, которая будет применяться к каждому элементу массива. В данном случае передается анонимная функция $sqrt.

function change_arr(array &$arr, callable $action) // callable это тип данных который принимает на вход другую функцию или метод
{
	//4. Функция change_arr проходит по всем элементам массива с помощью цикла foreach и для каждого элемента применяет переданную функцию $sqrt.
	foreach ($arr as &$item) {
		$item = $action($item);
	}
}
//5. В результате массив [0, -2, 3] превращается в [0, 4, 9] - каждый элемент массива был возведен в квадрат.
$array = [0, -2, 3];
change_arr($array, $sqrt);
var_dump($array);

//  анонимные функции 
//6. Создается анонимная функция $qwe, которая принимает два аргумента типа int или float и возвращает их разность.
$qwe = function (int|float $a, int|float $b): int|float {
	return $a - $b;
}; // в случае с анонимной функций обязательно ставим в конце ;
//7. Результат функции $qwe выводится с помощью var_dump.
var_dump($qwe);
